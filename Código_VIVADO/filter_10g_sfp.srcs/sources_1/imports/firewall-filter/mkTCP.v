//
// Generated by Bluespec Compiler (build 2c1ed34)
//
// On Wed Jun  9 13:35:20 -03 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_activate                   O     1 const
// RDY_parser                     O     1 const
// RDY_pairOrodd                  O     1 const
// RDY_headerPair                 O     1 const
// RDY_headerOdd                  O     1 const
// portSrc                        O    16 reg
// RDY_portSrc                    O     1 const
// portDst                        O    16 reg
// RDY_portDst                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// activate_v                     I     1 reg
// parser_d                       I    64 reg
// pairOrodd_signal               I     1 reg
// headerPair_pair                I    16 reg
// headerOdd_odd                  I    48 reg
// EN_activate                    I     1
// EN_parser                      I     1
// EN_pairOrodd                   I     1
// EN_headerPair                  I     1
// EN_headerOdd                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTCP(CLK,
	     RST_N,

	     activate_v,
	     EN_activate,
	     RDY_activate,

	     parser_d,
	     EN_parser,
	     RDY_parser,

	     pairOrodd_signal,
	     EN_pairOrodd,
	     RDY_pairOrodd,

	     headerPair_pair,
	     EN_headerPair,
	     RDY_headerPair,

	     headerOdd_odd,
	     EN_headerOdd,
	     RDY_headerOdd,

	     portSrc,
	     RDY_portSrc,

	     portDst,
	     RDY_portDst);
  input  CLK;
  input  RST_N;

  // action method activate
  input  activate_v;
  input  EN_activate;
  output RDY_activate;

  // action method parser
  input  [63 : 0] parser_d;
  input  EN_parser;
  output RDY_parser;

  // action method pairOrodd
  input  pairOrodd_signal;
  input  EN_pairOrodd;
  output RDY_pairOrodd;

  // action method headerPair
  input  [15 : 0] headerPair_pair;
  input  EN_headerPair;
  output RDY_headerPair;

  // action method headerOdd
  input  [47 : 0] headerOdd_odd;
  input  EN_headerOdd;
  output RDY_headerOdd;

  // value method portSrc
  output [15 : 0] portSrc;
  output RDY_portSrc;

  // value method portDst
  output [15 : 0] portDst;
  output RDY_portDst;

  // signals for module outputs
  wire [15 : 0] portDst, portSrc;
  wire RDY_activate,
       RDY_headerOdd,
       RDY_headerPair,
       RDY_pairOrodd,
       RDY_parser,
       RDY_portDst,
       RDY_portSrc;

  // inlined wires
  wire start_wire$whas, state_set_pw$whas;

  // register ack_num
  reg [31 : 0] ack_num;
  wire [31 : 0] ack_num$D_IN;
  wire ack_num$EN;

  // register active
  reg active;
  wire active$D_IN, active$EN;

  // register checksum
  reg [15 : 0] checksum;
  wire [15 : 0] checksum$D_IN;
  wire checksum$EN;

  // register data
  reg [63 : 0] data;
  wire [63 : 0] data$D_IN;
  wire data$EN;

  // register data_offset
  reg [3 : 0] data_offset;
  wire [3 : 0] data_offset$D_IN;
  wire data_offset$EN;

  // register flag_ack
  reg flag_ack;
  wire flag_ack$D_IN, flag_ack$EN;

  // register flag_cwr
  reg flag_cwr;
  wire flag_cwr$D_IN, flag_cwr$EN;

  // register flag_ece
  reg flag_ece;
  wire flag_ece$D_IN, flag_ece$EN;

  // register flag_fin
  reg flag_fin;
  wire flag_fin$D_IN, flag_fin$EN;

  // register flag_ns
  reg flag_ns;
  wire flag_ns$D_IN, flag_ns$EN;

  // register flag_psh
  reg flag_psh;
  wire flag_psh$D_IN, flag_psh$EN;

  // register flag_rst
  reg flag_rst;
  wire flag_rst$D_IN, flag_rst$EN;

  // register flag_syn
  reg flag_syn;
  wire flag_syn$D_IN, flag_syn$EN;

  // register flag_urg
  reg flag_urg;
  wire flag_urg$D_IN, flag_urg$EN;

  // register odd_header_down
  reg [47 : 0] odd_header_down;
  wire [47 : 0] odd_header_down$D_IN;
  wire odd_header_down$EN;

  // register odd_header_up
  reg [15 : 0] odd_header_up;
  wire [15 : 0] odd_header_up$D_IN;
  wire odd_header_up$EN;

  // register pair_header_down
  reg [15 : 0] pair_header_down;
  wire [15 : 0] pair_header_down$D_IN;
  wire pair_header_down$EN;

  // register pair_header_up
  reg [47 : 0] pair_header_up;
  wire [47 : 0] pair_header_up$D_IN;
  wire pair_header_up$EN;

  // register pair_odd
  reg pair_odd;
  wire pair_odd$D_IN, pair_odd$EN;

  // register port_dst
  reg [15 : 0] port_dst;
  wire [15 : 0] port_dst$D_IN;
  wire port_dst$EN;

  // register port_src
  reg [15 : 0] port_src;
  wire [15 : 0] port_src$D_IN;
  wire port_src$EN;

  // register reserved
  reg [2 : 0] reserved;
  wire [2 : 0] reserved$D_IN;
  wire reserved$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register seq_num
  reg [31 : 0] seq_num;
  wire [31 : 0] seq_num$D_IN;
  wire seq_num$EN;

  // register start_reg
  reg start_reg;
  wire start_reg$D_IN, start_reg$EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1$D_IN, start_reg_1$EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap$D_IN, state_can_overlap$EN;

  // register state_fired
  reg state_fired;
  wire state_fired$D_IN, state_fired$EN;

  // register state_mkFSMstate
  reg [3 : 0] state_mkFSMstate;
  reg [3 : 0] state_mkFSMstate$D_IN;
  wire state_mkFSMstate$EN;

  // register tcp_length
  reg [15 : 0] tcp_length;
  wire [15 : 0] tcp_length$D_IN;
  wire tcp_length$EN;

  // register temp
  reg [15 : 0] temp;
  wire [15 : 0] temp$D_IN;
  wire temp$EN;

  // register urgent_pointer
  reg [15 : 0] urgent_pointer;
  wire [15 : 0] urgent_pointer$D_IN;
  wire urgent_pointer$EN;

  // register valid_rcv
  reg valid_rcv;
  wire valid_rcv$D_IN, valid_rcv$EN;

  // register window_size
  reg [15 : 0] window_size;
  wire [15 : 0] window_size$D_IN;
  wire window_size$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_l161c41,
       WILL_FIRE_RL_action_l164c33,
       WILL_FIRE_RL_action_l93c25,
       WILL_FIRE_RL_fsm_start;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_ack_num$write_1__VAL_2;
  wire MUX_ack_num$write_1__SEL_1,
       MUX_start_reg$write_1__SEL_2,
       MUX_urgent_pointer$write_1__SEL_1,
       MUX_urgent_pointer$write_1__SEL_2;

  // remaining internal signals
  wire [31 : 0] x__h19778;
  wire abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101,
       start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38;

  // action method activate
  assign RDY_activate = 1'd1 ;

  // action method parser
  assign RDY_parser = 1'd1 ;

  // action method pairOrodd
  assign RDY_pairOrodd = 1'd1 ;

  // action method headerPair
  assign RDY_headerPair = 1'd1 ;

  // action method headerOdd
  assign RDY_headerOdd = 1'd1 ;

  // value method portSrc
  assign portSrc = port_src ;
  assign RDY_portSrc = 1'd1 ;

  // value method portDst
  assign portDst = port_dst ;
  assign RDY_portDst = 1'd1 ;

  // rule RL_action_l93c25
  assign WILL_FIRE_RL_action_l93c25 = active && state_mkFSMstate == 4'd1 ;

  // rule RL_action_l161c41
  assign WILL_FIRE_RL_action_l161c41 =
	     active &&
	     (state_mkFSMstate == 4'd4 || state_mkFSMstate == 4'd5) ;

  // rule RL_action_l164c33
  assign WILL_FIRE_RL_action_l164c33 =
	     !active &&
	     (state_mkFSMstate == 4'd4 || state_mkFSMstate == 4'd5) ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101 &&
	     start_reg ;

  // inputs to muxes for submodule ports
  assign MUX_ack_num$write_1__SEL_1 = WILL_FIRE_RL_action_l93c25 && pair_odd ;
  assign MUX_start_reg$write_1__SEL_2 =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101 &&
	     !start_reg &&
	     !running ;
  assign MUX_urgent_pointer$write_1__SEL_1 =
	     state_mkFSMstate == 4'd2 && pair_odd ;
  assign MUX_urgent_pointer$write_1__SEL_2 =
	     state_mkFSMstate == 4'd3 && !pair_odd ;
  assign MUX_ack_num$write_1__VAL_2 = { temp, data[63:48] } ;

  // inlined wires
  assign start_wire$whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign state_set_pw$whas =
	     WILL_FIRE_RL_action_l164c33 || WILL_FIRE_RL_action_l161c41 ||
	     state_mkFSMstate == 4'd3 ||
	     state_mkFSMstate == 4'd2 ||
	     WILL_FIRE_RL_action_l93c25 ||
	     start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 ;

  // register ack_num
  assign ack_num$D_IN =
	     MUX_ack_num$write_1__SEL_1 ?
	       data[47:16] :
	       MUX_ack_num$write_1__VAL_2 ;
  assign ack_num$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register active
  assign active$D_IN = activate_v ;
  assign active$EN = EN_activate ;

  // register checksum
  assign checksum$D_IN = pair_odd ? data[47:32] : data[15:0] ;
  assign checksum$EN = state_mkFSMstate == 4'd2 ;

  // register data
  assign data$D_IN = parser_d ;
  assign data$EN = EN_parser ;

  // register data_offset
  assign data_offset$D_IN =
	     MUX_ack_num$write_1__SEL_1 ? data[15:12] : data[47:44] ;
  assign data_offset$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_ack
  assign flag_ack$D_IN = MUX_ack_num$write_1__SEL_1 ? data[4] : data[36] ;
  assign flag_ack$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_cwr
  assign flag_cwr$D_IN = MUX_ack_num$write_1__SEL_1 ? data[7] : data[39] ;
  assign flag_cwr$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_ece
  assign flag_ece$D_IN = MUX_ack_num$write_1__SEL_1 ? data[6] : data[38] ;
  assign flag_ece$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_fin
  assign flag_fin$D_IN = MUX_ack_num$write_1__SEL_1 ? data[0] : data[32] ;
  assign flag_fin$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_ns
  assign flag_ns$D_IN = MUX_ack_num$write_1__SEL_1 ? data[8] : data[40] ;
  assign flag_ns$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_psh
  assign flag_psh$D_IN = MUX_ack_num$write_1__SEL_1 ? data[3] : data[35] ;
  assign flag_psh$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_rst
  assign flag_rst$D_IN = MUX_ack_num$write_1__SEL_1 ? data[2] : data[34] ;
  assign flag_rst$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_syn
  assign flag_syn$D_IN = MUX_ack_num$write_1__SEL_1 ? data[1] : data[33] ;
  assign flag_syn$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register flag_urg
  assign flag_urg$D_IN = MUX_ack_num$write_1__SEL_1 ? data[5] : data[37] ;
  assign flag_urg$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register odd_header_down
  assign odd_header_down$D_IN = headerOdd_odd ;
  assign odd_header_down$EN = EN_headerOdd ;

  // register odd_header_up
  assign odd_header_up$D_IN = data[15:0] ;
  assign odd_header_up$EN = MUX_urgent_pointer$write_1__SEL_1 ;

  // register pair_header_down
  assign pair_header_down$D_IN = headerPair_pair ;
  assign pair_header_down$EN = EN_headerPair ;

  // register pair_header_up
  assign pair_header_up$D_IN = data[47:0] ;
  assign pair_header_up$EN = MUX_urgent_pointer$write_1__SEL_2 ;

  // register pair_odd
  assign pair_odd$D_IN = pairOrodd_signal ;
  assign pair_odd$EN = EN_pairOrodd ;

  // register port_dst
  assign port_dst$D_IN = pair_odd ? odd_header_down[31:16] : data[63:48] ;
  assign port_dst$EN = WILL_FIRE_RL_action_l93c25 ;

  // register port_src
  assign port_src$D_IN =
	     pair_odd ? odd_header_down[47:32] : pair_header_down ;
  assign port_src$EN = WILL_FIRE_RL_action_l93c25 ;

  // register reserved
  assign reserved$D_IN =
	     MUX_ack_num$write_1__SEL_1 ? data[11:9] : data[43:41] ;
  assign reserved$EN =
	     WILL_FIRE_RL_action_l93c25 && pair_odd ||
	     state_mkFSMstate == 4'd2 && !pair_odd ;

  // register running
  assign running$D_IN = 1'd1 ;
  assign running$EN = MUX_start_reg$write_1__SEL_2 ;

  // register seq_num
  assign seq_num$D_IN = pair_odd ? x__h19778 : data[47:16] ;
  assign seq_num$EN = WILL_FIRE_RL_action_l93c25 ;

  // register start_reg
  assign start_reg$D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg$EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101 &&
	     !start_reg &&
	     !running ;

  // register start_reg_1
  assign start_reg_1$D_IN = start_wire$whas ;
  assign start_reg_1$EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap$D_IN = state_set_pw$whas || state_can_overlap ;
  assign state_can_overlap$EN = 1'd1 ;

  // register state_fired
  assign state_fired$D_IN = state_set_pw$whas ;
  assign state_fired$EN = 1'd1 ;

  // register state_mkFSMstate
  always@(start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 or
	  WILL_FIRE_RL_action_l93c25 or
	  state_mkFSMstate or
	  WILL_FIRE_RL_action_l161c41 or WILL_FIRE_RL_action_l164c33)
  begin
    case (1'b1) // synopsys parallel_case
      start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38:
	  state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_action_l93c25: state_mkFSMstate$D_IN = 4'd2;
      state_mkFSMstate == 4'd2: state_mkFSMstate$D_IN = 4'd3;
      state_mkFSMstate == 4'd3: state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_action_l161c41: state_mkFSMstate$D_IN = 4'd5;
      WILL_FIRE_RL_action_l164c33: state_mkFSMstate$D_IN = 4'd6;
      default: state_mkFSMstate$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate$EN =
	     start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 ||
	     WILL_FIRE_RL_action_l93c25 ||
	     state_mkFSMstate == 4'd2 ||
	     state_mkFSMstate == 4'd3 ||
	     WILL_FIRE_RL_action_l161c41 ||
	     WILL_FIRE_RL_action_l164c33 ;

  // register tcp_length
  assign tcp_length$D_IN = 16'h0 ;
  assign tcp_length$EN = 1'b0 ;

  // register temp
  assign temp$D_IN = data[15:0] ;
  assign temp$EN = WILL_FIRE_RL_action_l93c25 && !pair_odd ;

  // register urgent_pointer
  assign urgent_pointer$D_IN =
	     MUX_urgent_pointer$write_1__SEL_1 ? data[31:16] : data[63:48] ;
  assign urgent_pointer$EN =
	     state_mkFSMstate == 4'd2 && pair_odd ||
	     state_mkFSMstate == 4'd3 && !pair_odd ;

  // register valid_rcv
  assign valid_rcv$D_IN = 1'd0 ;
  assign valid_rcv$EN =
	     start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 ;

  // register window_size
  assign window_size$D_IN = pair_odd ? data[63:48] : data[31:16] ;
  assign window_size$EN = state_mkFSMstate == 4'd2 ;

  // remaining internal signals
  assign abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101 =
	     state_mkFSMstate == 4'd0 && (!start_reg_1 || state_fired) ;
  assign start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 =
	     start_wire$whas && state_mkFSMstate == 4'd0 ||
	     state_mkFSMstate == 4'd6 ;
  assign x__h19778 = { odd_header_down[15:0], data[63:48] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        ack_num <= `BSV_ASSIGNMENT_DELAY 32'hAAAAAAAA;
	active <= `BSV_ASSIGNMENT_DELAY 1'd0;
	checksum <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	data <= `BSV_ASSIGNMENT_DELAY 64'hAAAAAAAAAAAAAAAA;
	data_offset <= `BSV_ASSIGNMENT_DELAY 4'hA;
	flag_ack <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_cwr <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_ece <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_fin <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_ns <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_psh <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_rst <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_syn <= `BSV_ASSIGNMENT_DELAY 1'h0;
	flag_urg <= `BSV_ASSIGNMENT_DELAY 1'h0;
	odd_header_down <= `BSV_ASSIGNMENT_DELAY 48'hAAAAAAAAAAAA;
	odd_header_up <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	pair_header_down <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	pair_header_up <= `BSV_ASSIGNMENT_DELAY 48'hAAAAAAAAAAAA;
	pair_odd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	port_dst <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	port_src <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	reserved <= `BSV_ASSIGNMENT_DELAY 3'h2;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	seq_num <= `BSV_ASSIGNMENT_DELAY 32'hAAAAAAAA;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tcp_length <= `BSV_ASSIGNMENT_DELAY 16'h0;
	temp <= `BSV_ASSIGNMENT_DELAY 16'h0;
	urgent_pointer <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	valid_rcv <= `BSV_ASSIGNMENT_DELAY 1'd0;
	window_size <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
      end
    else
      begin
        if (ack_num$EN) ack_num <= `BSV_ASSIGNMENT_DELAY ack_num$D_IN;
	if (active$EN) active <= `BSV_ASSIGNMENT_DELAY active$D_IN;
	if (checksum$EN) checksum <= `BSV_ASSIGNMENT_DELAY checksum$D_IN;
	if (data$EN) data <= `BSV_ASSIGNMENT_DELAY data$D_IN;
	if (data_offset$EN)
	  data_offset <= `BSV_ASSIGNMENT_DELAY data_offset$D_IN;
	if (flag_ack$EN) flag_ack <= `BSV_ASSIGNMENT_DELAY flag_ack$D_IN;
	if (flag_cwr$EN) flag_cwr <= `BSV_ASSIGNMENT_DELAY flag_cwr$D_IN;
	if (flag_ece$EN) flag_ece <= `BSV_ASSIGNMENT_DELAY flag_ece$D_IN;
	if (flag_fin$EN) flag_fin <= `BSV_ASSIGNMENT_DELAY flag_fin$D_IN;
	if (flag_ns$EN) flag_ns <= `BSV_ASSIGNMENT_DELAY flag_ns$D_IN;
	if (flag_psh$EN) flag_psh <= `BSV_ASSIGNMENT_DELAY flag_psh$D_IN;
	if (flag_rst$EN) flag_rst <= `BSV_ASSIGNMENT_DELAY flag_rst$D_IN;
	if (flag_syn$EN) flag_syn <= `BSV_ASSIGNMENT_DELAY flag_syn$D_IN;
	if (flag_urg$EN) flag_urg <= `BSV_ASSIGNMENT_DELAY flag_urg$D_IN;
	if (odd_header_down$EN)
	  odd_header_down <= `BSV_ASSIGNMENT_DELAY odd_header_down$D_IN;
	if (odd_header_up$EN)
	  odd_header_up <= `BSV_ASSIGNMENT_DELAY odd_header_up$D_IN;
	if (pair_header_down$EN)
	  pair_header_down <= `BSV_ASSIGNMENT_DELAY pair_header_down$D_IN;
	if (pair_header_up$EN)
	  pair_header_up <= `BSV_ASSIGNMENT_DELAY pair_header_up$D_IN;
	if (pair_odd$EN) pair_odd <= `BSV_ASSIGNMENT_DELAY pair_odd$D_IN;
	if (port_dst$EN) port_dst <= `BSV_ASSIGNMENT_DELAY port_dst$D_IN;
	if (port_src$EN) port_src <= `BSV_ASSIGNMENT_DELAY port_src$D_IN;
	if (reserved$EN) reserved <= `BSV_ASSIGNMENT_DELAY reserved$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (seq_num$EN) seq_num <= `BSV_ASSIGNMENT_DELAY seq_num$D_IN;
	if (start_reg$EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg$D_IN;
	if (start_reg_1$EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1$D_IN;
	if (state_can_overlap$EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap$D_IN;
	if (state_fired$EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired$D_IN;
	if (state_mkFSMstate$EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate$D_IN;
	if (tcp_length$EN)
	  tcp_length <= `BSV_ASSIGNMENT_DELAY tcp_length$D_IN;
	if (temp$EN) temp <= `BSV_ASSIGNMENT_DELAY temp$D_IN;
	if (urgent_pointer$EN)
	  urgent_pointer <= `BSV_ASSIGNMENT_DELAY urgent_pointer$D_IN;
	if (valid_rcv$EN) valid_rcv <= `BSV_ASSIGNMENT_DELAY valid_rcv$D_IN;
	if (window_size$EN)
	  window_size <= `BSV_ASSIGNMENT_DELAY window_size$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    ack_num = 32'hAAAAAAAA;
    active = 1'h0;
    checksum = 16'hAAAA;
    data = 64'hAAAAAAAAAAAAAAAA;
    data_offset = 4'hA;
    flag_ack = 1'h0;
    flag_cwr = 1'h0;
    flag_ece = 1'h0;
    flag_fin = 1'h0;
    flag_ns = 1'h0;
    flag_psh = 1'h0;
    flag_rst = 1'h0;
    flag_syn = 1'h0;
    flag_urg = 1'h0;
    odd_header_down = 48'hAAAAAAAAAAAA;
    odd_header_up = 16'hAAAA;
    pair_header_down = 16'hAAAA;
    pair_header_up = 48'hAAAAAAAAAAAA;
    pair_odd = 1'h0;
    port_dst = 16'hAAAA;
    port_src = 16'hAAAA;
    reserved = 3'h2;
    running = 1'h0;
    seq_num = 32'hAAAAAAAA;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 4'hA;
    tcp_length = 16'hAAAA;
    temp = 16'hAAAA;
    urgent_pointer = 16'hAAAA;
    valid_rcv = 1'h0;
    window_size = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l93c25 &&
	  (state_mkFSMstate == 4'd2 || state_mkFSMstate == 4'd3 ||
	   WILL_FIRE_RL_action_l161c41 ||
	   WILL_FIRE_RL_action_l164c33))
	$display("Error: \"TCP.bsv\", line 93, column 25: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l93c25] and\n  [RL_action_l122c25, RL_action_l151c25, RL_action_l161c41, RL_action_l164c33]\n  ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 4'd2 &&
	  (state_mkFSMstate == 4'd3 || WILL_FIRE_RL_action_l161c41 ||
	   WILL_FIRE_RL_action_l164c33))
	$display("Error: \"TCP.bsv\", line 122, column 25: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l122c25] and\n  [RL_action_l151c25, RL_action_l161c41, RL_action_l164c33] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 4'd3 &&
	  (WILL_FIRE_RL_action_l161c41 || WILL_FIRE_RL_action_l164c33))
	$display("Error: \"TCP.bsv\", line 151, column 25: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l151c25] and\n  [RL_action_l161c41, RL_action_l164c33] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l161c41 && WILL_FIRE_RL_action_l164c33)
	$display("Error: \"TCP.bsv\", line 161, column 41: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l161c41] and\n  [RL_action_l164c33] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (start_wire_whas_AND_start_wire_wget_0_AND_abor_ETC___d38 &&
	  (WILL_FIRE_RL_action_l93c25 || state_mkFSMstate == 4'd2 ||
	   state_mkFSMstate == 4'd3 ||
	   WILL_FIRE_RL_action_l161c41 ||
	   WILL_FIRE_RL_action_l164c33))
	$display("Error: \"TCP.bsv\", line 90, column 35: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l90c35] and\n  [RL_action_l93c25, RL_action_l122c25, RL_action_l151c25, RL_action_l161c41,\n  RL_action_l164c33] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d101 &&
	  !start_reg)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkTCP

