//
// Generated by Bluespec Compiler (build 2c1ed34)
//
// On Mon Jun 14 13:15:57 -03 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_fifoToCheck                O     1 reg
// RDY_fifoToFilter               O     1 reg
// validSend                      O     1 reg
// RDY_validSend                  O     1 const
// getToSend                      O    73 reg
// RDY_getToSend                  O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fifoToCheck_v                  I   294 reg
// fifoToFilter_d                 I    73 reg
// EN_fifoToCheck                 I     1
// EN_fifoToFilter                I     1
// EN_getToSend                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFilter(CLK,
		RST_N,

		fifoToCheck_v,
		EN_fifoToCheck,
		RDY_fifoToCheck,

		fifoToFilter_d,
		EN_fifoToFilter,
		RDY_fifoToFilter,

		validSend,
		RDY_validSend,

		EN_getToSend,
		getToSend,
		RDY_getToSend);
  input  CLK;
  input  RST_N;

  // action method fifoToCheck
  input  [293 : 0] fifoToCheck_v;
  input  EN_fifoToCheck;
  output RDY_fifoToCheck;

  // action method fifoToFilter
  input  [72 : 0] fifoToFilter_d;
  input  EN_fifoToFilter;
  output RDY_fifoToFilter;

  // value method validSend
  output validSend;
  output RDY_validSend;

  // actionvalue method getToSend
  input  EN_getToSend;
  output [72 : 0] getToSend;
  output RDY_getToSend;

  // signals for module outputs
  wire [72 : 0] getToSend;
  wire RDY_fifoToCheck,
       RDY_fifoToFilter,
       RDY_getToSend,
       RDY_validSend,
       validSend;

  // inlined wires
  wire start_wire$whas, state_set_pw$whas;

  // register active
  reg active;
  wire active$D_IN, active$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register start_reg
  reg start_reg;
  wire start_reg$D_IN, start_reg$EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1$D_IN, start_reg_1$EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap$D_IN, state_can_overlap$EN;

  // register state_fired
  reg state_fired;
  wire state_fired$D_IN, state_fired$EN;

  // register state_mkFSMstate
  reg [3 : 0] state_mkFSMstate;
  reg [3 : 0] state_mkFSMstate$D_IN;
  wire state_mkFSMstate$EN;

  // register tx_data
  reg [63 : 0] tx_data;
  wire [63 : 0] tx_data$D_IN;
  wire tx_data$EN;

  // register tx_keep
  reg [7 : 0] tx_keep;
  wire [7 : 0] tx_keep$D_IN;
  wire tx_keep$EN;

  // register tx_last
  reg tx_last;
  wire tx_last$D_IN, tx_last$EN;

  // register tx_ready
  reg tx_ready;
  wire tx_ready$D_IN, tx_ready$EN;

  // register tx_user
  reg tx_user;
  wire tx_user$D_IN, tx_user$EN;

  // register tx_valid
  reg tx_valid;
  wire tx_valid$D_IN, tx_valid$EN;

  // ports of submodule fifoCheck
  wire [293 : 0] fifoCheck$D_IN, fifoCheck$D_OUT;
  wire fifoCheck$CLR,
       fifoCheck$DEQ,
       fifoCheck$EMPTY_N,
       fifoCheck$ENQ,
       fifoCheck$FULL_N;

  // ports of submodule fifoIn
  wire [72 : 0] fifoIn$D_IN, fifoIn$D_OUT;
  wire fifoIn$CLR, fifoIn$DEQ, fifoIn$EMPTY_N, fifoIn$ENQ, fifoIn$FULL_N;

  // ports of submodule fifoOut
  wire [72 : 0] fifoOut$D_IN, fifoOut$D_OUT;
  wire fifoOut$CLR, fifoOut$DEQ, fifoOut$EMPTY_N, fifoOut$ENQ, fifoOut$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_l110c30,
       WILL_FIRE_RL_action_l118c50,
       WILL_FIRE_RL_action_l122c49,
       WILL_FIRE_RL_action_l128c41,
       WILL_FIRE_RL_action_l141c50,
       WILL_FIRE_RL_action_l145c49,
       WILL_FIRE_RL_action_l151c41,
       WILL_FIRE_RL_action_l162c50,
       WILL_FIRE_RL_action_l166c49,
       WILL_FIRE_RL_action_l172c41,
       WILL_FIRE_RL_action_l183c50,
       WILL_FIRE_RL_action_l186c55,
       WILL_FIRE_RL_action_l188c47,
       WILL_FIRE_RL_fsm_start;

  // inputs to muxes for submodule ports
  wire MUX_start_reg$write_1__SEL_2;

  // remaining internal signals
  wire NOT_fifoCheck_first__1_BITS_293_TO_290_2_EQ_4__ETC___d188,
       NOT_fifoCheck_first__1_BITS_31_TO_16_6_ULT_600_ETC___d172,
       abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201,
       fifoCheck_first__1_BITS_15_TO_0_1_ULE_10___d125,
       fifoCheck_first__1_BITS_15_TO_0_1_ULE_6010___d73,
       fifoCheck_first__1_BITS_15_TO_0_1_ULT_6000___d72,
       fifoCheck_first__1_BITS_293_TO_290_2_EQ_6_11_A_ETC___d138,
       fifoCheck_first__1_BITS_31_TO_16_6_ULE_10___d122,
       fifoCheck_first__1_BITS_31_TO_16_6_ULE_6010___d68,
       fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000_7__ETC___d90,
       fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000___d67;

  // action method fifoToCheck
  assign RDY_fifoToCheck = fifoCheck$FULL_N ;

  // action method fifoToFilter
  assign RDY_fifoToFilter = fifoIn$FULL_N ;

  // value method validSend
  assign validSend = fifoOut$EMPTY_N ;
  assign RDY_validSend = 1'd1 ;

  // actionvalue method getToSend
  assign getToSend = fifoOut$D_OUT ;
  assign RDY_getToSend = fifoOut$EMPTY_N ;

  // submodule fifoCheck
  SizedFIFO #(.p1width(32'd294),
	      .p2depth(32'd32),
	      .p3cntr_width(32'd5),
	      .guarded(1'd1)) fifoCheck(.RST(RST_N),
					.CLK(CLK),
					.D_IN(fifoCheck$D_IN),
					.ENQ(fifoCheck$ENQ),
					.DEQ(fifoCheck$DEQ),
					.CLR(fifoCheck$CLR),
					.D_OUT(fifoCheck$D_OUT),
					.FULL_N(fifoCheck$FULL_N),
					.EMPTY_N(fifoCheck$EMPTY_N));

  // submodule fifoIn
  SizedFIFO #(.p1width(32'd73),
	      .p2depth(32'd128),
	      .p3cntr_width(32'd7),
	      .guarded(1'd1)) fifoIn(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(fifoIn$D_IN),
				     .ENQ(fifoIn$ENQ),
				     .DEQ(fifoIn$DEQ),
				     .CLR(fifoIn$CLR),
				     .D_OUT(fifoIn$D_OUT),
				     .FULL_N(fifoIn$FULL_N),
				     .EMPTY_N(fifoIn$EMPTY_N));

  // submodule fifoOut
  SizedFIFO #(.p1width(32'd73),
	      .p2depth(32'd32),
	      .p3cntr_width(32'd5),
	      .guarded(1'd1)) fifoOut(.RST(RST_N),
				      .CLK(CLK),
				      .D_IN(fifoOut$D_IN),
				      .ENQ(fifoOut$ENQ),
				      .DEQ(fifoOut$DEQ),
				      .CLR(fifoOut$CLR),
				      .D_OUT(fifoOut$D_OUT),
				      .FULL_N(fifoOut$FULL_N),
				      .EMPTY_N(fifoOut$EMPTY_N));

  // rule RL_action_l118c50
  assign WILL_FIRE_RL_action_l118c50 =
	     fifoCheck$EMPTY_N && fifoCheck$D_OUT[293:290] == 4'd4 &&
	     !fifoCheck$D_OUT[289] &&
	     fifoCheck$D_OUT[288] &&
	     fifoCheck$D_OUT[95:72] != 24'd12625971 &&
	     fifoCheck$D_OUT[63:40] != 24'd12625971 &&
	     fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000_7__ETC___d90 &&
	     state_mkFSMstate == 4'd1 ;

  // rule RL_action_l122c49
  assign WILL_FIRE_RL_action_l122c49 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && !fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd2 || state_mkFSMstate == 4'd3) ;

  // rule RL_action_l128c41
  assign WILL_FIRE_RL_action_l128c41 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd2 || state_mkFSMstate == 4'd3) ;

  // rule RL_action_l141c50
  assign WILL_FIRE_RL_action_l141c50 =
	     fifoCheck$EMPTY_N &&
	     fifoCheck_first__1_BITS_293_TO_290_2_EQ_6_11_A_ETC___d138 ;

  // rule RL_action_l145c49
  assign WILL_FIRE_RL_action_l145c49 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && !fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd5 || state_mkFSMstate == 4'd6) ;

  // rule RL_action_l151c41
  assign WILL_FIRE_RL_action_l151c41 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd5 || state_mkFSMstate == 4'd6) ;

  // rule RL_action_l162c50
  assign WILL_FIRE_RL_action_l162c50 =
	     fifoCheck$EMPTY_N && !fifoCheck$D_OUT[289] &&
	     !fifoCheck$D_OUT[288] &&
	     state_mkFSMstate == 4'd1 ;

  // rule RL_action_l166c49
  assign WILL_FIRE_RL_action_l166c49 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && !fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd8 || state_mkFSMstate == 4'd9) ;

  // rule RL_action_l172c41
  assign WILL_FIRE_RL_action_l172c41 =
	     fifoIn$EMPTY_N && fifoOut$FULL_N && fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd8 || state_mkFSMstate == 4'd9) ;

  // rule RL_action_l183c50
  assign WILL_FIRE_RL_action_l183c50 =
	     fifoCheck$EMPTY_N &&
	     NOT_fifoCheck_first__1_BITS_293_TO_290_2_EQ_4__ETC___d188 &&
	     state_mkFSMstate == 4'd1 ;

  // rule RL_action_l186c55
  assign WILL_FIRE_RL_action_l186c55 =
	     fifoIn$EMPTY_N && !fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd11 || state_mkFSMstate == 4'd12) ;

  // rule RL_action_l188c47
  assign WILL_FIRE_RL_action_l188c47 =
	     fifoIn$EMPTY_N && fifoIn$D_OUT[72] &&
	     (state_mkFSMstate == 4'd11 || state_mkFSMstate == 4'd12) ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201 &&
	     start_reg ;

  // rule RL_action_l110c30
  assign WILL_FIRE_RL_action_l110c30 =
	     fifoCheck$EMPTY_N &&
	     (start_wire$whas && state_mkFSMstate == 4'd0 ||
	      state_mkFSMstate == 4'd4 ||
	      state_mkFSMstate == 4'd7 ||
	      state_mkFSMstate == 4'd10 ||
	      state_mkFSMstate == 4'd13) ;

  // inputs to muxes for submodule ports
  assign MUX_start_reg$write_1__SEL_2 =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201 &&
	     !start_reg &&
	     !running ;

  // inlined wires
  assign start_wire$whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign state_set_pw$whas =
	     WILL_FIRE_RL_action_l188c47 || WILL_FIRE_RL_action_l186c55 ||
	     WILL_FIRE_RL_action_l183c50 ||
	     WILL_FIRE_RL_action_l172c41 ||
	     WILL_FIRE_RL_action_l166c49 ||
	     WILL_FIRE_RL_action_l162c50 ||
	     WILL_FIRE_RL_action_l151c41 ||
	     WILL_FIRE_RL_action_l145c49 ||
	     WILL_FIRE_RL_action_l141c50 ||
	     WILL_FIRE_RL_action_l128c41 ||
	     WILL_FIRE_RL_action_l122c49 ||
	     WILL_FIRE_RL_action_l118c50 ||
	     WILL_FIRE_RL_action_l110c30 ;

  // register active
  assign active$D_IN = 1'b0 ;
  assign active$EN = 1'b0 ;

  // register running
  assign running$D_IN = 1'd1 ;
  assign running$EN = MUX_start_reg$write_1__SEL_2 ;

  // register start_reg
  assign start_reg$D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg$EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201 &&
	     !start_reg &&
	     !running ;

  // register start_reg_1
  assign start_reg_1$D_IN = start_wire$whas ;
  assign start_reg_1$EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap$D_IN = state_set_pw$whas || state_can_overlap ;
  assign state_can_overlap$EN = 1'd1 ;

  // register state_fired
  assign state_fired$D_IN = state_set_pw$whas ;
  assign state_fired$EN = 1'd1 ;

  // register state_mkFSMstate
  always@(WILL_FIRE_RL_action_l110c30 or
	  WILL_FIRE_RL_action_l118c50 or
	  WILL_FIRE_RL_action_l122c49 or
	  WILL_FIRE_RL_action_l128c41 or
	  WILL_FIRE_RL_action_l141c50 or
	  WILL_FIRE_RL_action_l145c49 or
	  WILL_FIRE_RL_action_l151c41 or
	  WILL_FIRE_RL_action_l162c50 or
	  WILL_FIRE_RL_action_l166c49 or
	  WILL_FIRE_RL_action_l172c41 or
	  WILL_FIRE_RL_action_l183c50 or
	  WILL_FIRE_RL_action_l186c55 or WILL_FIRE_RL_action_l188c47)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_action_l110c30: state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_action_l118c50: state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_action_l122c49: state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_action_l128c41: state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_action_l141c50: state_mkFSMstate$D_IN = 4'd5;
      WILL_FIRE_RL_action_l145c49: state_mkFSMstate$D_IN = 4'd6;
      WILL_FIRE_RL_action_l151c41: state_mkFSMstate$D_IN = 4'd7;
      WILL_FIRE_RL_action_l162c50: state_mkFSMstate$D_IN = 4'd8;
      WILL_FIRE_RL_action_l166c49: state_mkFSMstate$D_IN = 4'd9;
      WILL_FIRE_RL_action_l172c41: state_mkFSMstate$D_IN = 4'd10;
      WILL_FIRE_RL_action_l183c50: state_mkFSMstate$D_IN = 4'd11;
      WILL_FIRE_RL_action_l186c55: state_mkFSMstate$D_IN = 4'd12;
      WILL_FIRE_RL_action_l188c47: state_mkFSMstate$D_IN = 4'd13;
      default: state_mkFSMstate$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate$EN =
	     WILL_FIRE_RL_action_l110c30 || WILL_FIRE_RL_action_l118c50 ||
	     WILL_FIRE_RL_action_l122c49 ||
	     WILL_FIRE_RL_action_l128c41 ||
	     WILL_FIRE_RL_action_l141c50 ||
	     WILL_FIRE_RL_action_l145c49 ||
	     WILL_FIRE_RL_action_l151c41 ||
	     WILL_FIRE_RL_action_l162c50 ||
	     WILL_FIRE_RL_action_l166c49 ||
	     WILL_FIRE_RL_action_l172c41 ||
	     WILL_FIRE_RL_action_l183c50 ||
	     WILL_FIRE_RL_action_l186c55 ||
	     WILL_FIRE_RL_action_l188c47 ;

  // register tx_data
  assign tx_data$D_IN = 64'h0 ;
  assign tx_data$EN = 1'b0 ;

  // register tx_keep
  assign tx_keep$D_IN = 8'h0 ;
  assign tx_keep$EN = 1'b0 ;

  // register tx_last
  assign tx_last$D_IN = 1'b0 ;
  assign tx_last$EN = 1'b0 ;

  // register tx_ready
  assign tx_ready$D_IN = 1'b0 ;
  assign tx_ready$EN = 1'b0 ;

  // register tx_user
  assign tx_user$D_IN = 1'b0 ;
  assign tx_user$EN = 1'b0 ;

  // register tx_valid
  assign tx_valid$D_IN = 1'b0 ;
  assign tx_valid$EN = 1'b0 ;

  // submodule fifoCheck
  assign fifoCheck$D_IN = fifoToCheck_v ;
  assign fifoCheck$ENQ = EN_fifoToCheck ;
  assign fifoCheck$DEQ =
	     WILL_FIRE_RL_action_l183c50 || WILL_FIRE_RL_action_l162c50 ||
	     WILL_FIRE_RL_action_l141c50 ||
	     WILL_FIRE_RL_action_l118c50 ;
  assign fifoCheck$CLR = 1'b0 ;

  // submodule fifoIn
  assign fifoIn$D_IN = fifoToFilter_d ;
  assign fifoIn$ENQ = EN_fifoToFilter ;
  assign fifoIn$DEQ =
	     WILL_FIRE_RL_action_l188c47 || WILL_FIRE_RL_action_l186c55 ||
	     WILL_FIRE_RL_action_l172c41 ||
	     WILL_FIRE_RL_action_l166c49 ||
	     WILL_FIRE_RL_action_l151c41 ||
	     WILL_FIRE_RL_action_l145c49 ||
	     WILL_FIRE_RL_action_l128c41 ||
	     WILL_FIRE_RL_action_l122c49 ;
  assign fifoIn$CLR = 1'b0 ;

  // submodule fifoOut
  assign fifoOut$D_IN = fifoIn$D_OUT ;
  assign fifoOut$ENQ =
	     WILL_FIRE_RL_action_l172c41 || WILL_FIRE_RL_action_l166c49 ||
	     WILL_FIRE_RL_action_l151c41 ||
	     WILL_FIRE_RL_action_l145c49 ||
	     WILL_FIRE_RL_action_l128c41 ||
	     WILL_FIRE_RL_action_l122c49 ;
  assign fifoOut$DEQ = EN_getToSend ;
  assign fifoOut$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_fifoCheck_first__1_BITS_293_TO_290_2_EQ_4__ETC___d188 =
	     (fifoCheck$D_OUT[293:290] != 4'd4 || fifoCheck$D_OUT[289] ||
	      !fifoCheck$D_OUT[288] ||
	      fifoCheck$D_OUT[95:72] == 24'd12625971 ||
	      fifoCheck$D_OUT[63:40] == 24'd12625971 ||
	      NOT_fifoCheck_first__1_BITS_31_TO_16_6_ULT_600_ETC___d172) &&
	     (fifoCheck$D_OUT[293:290] != 4'd6 || fifoCheck$D_OUT[289] ||
	      !fifoCheck$D_OUT[288] ||
	      fifoCheck$D_OUT[287:224] == 64'h0A00000000000000 ||
	      fifoCheck$D_OUT[159:96] == 64'h0A00000000000000 ||
	      fifoCheck$D_OUT[31:16] != 16'd0 &&
	      fifoCheck_first__1_BITS_31_TO_16_6_ULE_10___d122 ||
	      fifoCheck_first__1_BITS_15_TO_0_1_ULE_10___d125 ||
	      fifoCheck$D_OUT[159:32] ==
	      128'h0000000000CB06405F15500082C00E00 ||
	      fifoCheck$D_OUT[287:160] ==
	      128'h0000000000CB06405F15500082C00E00) &&
	     (fifoCheck$D_OUT[289] || fifoCheck$D_OUT[288]) ;
  assign NOT_fifoCheck_first__1_BITS_31_TO_16_6_ULT_600_ETC___d172 =
	     !fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000___d67 &&
	     fifoCheck_first__1_BITS_31_TO_16_6_ULE_6010___d68 ||
	     !fifoCheck_first__1_BITS_15_TO_0_1_ULT_6000___d72 &&
	     fifoCheck_first__1_BITS_15_TO_0_1_ULE_6010___d73 ||
	     fifoCheck$D_OUT[63:32] == 32'hC0A80F04 ||
	     fifoCheck$D_OUT[95:64] == 32'hC0A83303 ||
	     fifoCheck$D_OUT[63:32] == 32'hC0A83303 &&
	     fifoCheck$D_OUT[15:0] == 16'd6000 ;
  assign abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201 =
	     state_mkFSMstate == 4'd0 && (!start_reg_1 || state_fired) ;
  assign fifoCheck_first__1_BITS_15_TO_0_1_ULE_10___d125 =
	     fifoCheck$D_OUT[15:0] <= 16'd10 ;
  assign fifoCheck_first__1_BITS_15_TO_0_1_ULE_6010___d73 =
	     fifoCheck$D_OUT[15:0] <= 16'd6010 ;
  assign fifoCheck_first__1_BITS_15_TO_0_1_ULT_6000___d72 =
	     fifoCheck$D_OUT[15:0] < 16'd6000 ;
  assign fifoCheck_first__1_BITS_293_TO_290_2_EQ_6_11_A_ETC___d138 =
	     fifoCheck$D_OUT[293:290] == 4'd6 && !fifoCheck$D_OUT[289] &&
	     fifoCheck$D_OUT[288] &&
	     fifoCheck$D_OUT[287:224] != 64'h0A00000000000000 &&
	     fifoCheck$D_OUT[159:96] != 64'h0A00000000000000 &&
	     (fifoCheck$D_OUT[31:16] == 16'd0 ||
	      !fifoCheck_first__1_BITS_31_TO_16_6_ULE_10___d122) &&
	     !fifoCheck_first__1_BITS_15_TO_0_1_ULE_10___d125 &&
	     fifoCheck$D_OUT[159:32] !=
	     128'h0000000000CB06405F15500082C00E00 &&
	     fifoCheck$D_OUT[287:160] !=
	     128'h0000000000CB06405F15500082C00E00 &&
	     state_mkFSMstate == 4'd1 ;
  assign fifoCheck_first__1_BITS_31_TO_16_6_ULE_10___d122 =
	     fifoCheck$D_OUT[31:16] <= 16'd10 ;
  assign fifoCheck_first__1_BITS_31_TO_16_6_ULE_6010___d68 =
	     fifoCheck$D_OUT[31:16] <= 16'd6010 ;
  assign fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000_7__ETC___d90 =
	     (fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000___d67 ||
	      !fifoCheck_first__1_BITS_31_TO_16_6_ULE_6010___d68) &&
	     (fifoCheck_first__1_BITS_15_TO_0_1_ULT_6000___d72 ||
	      !fifoCheck_first__1_BITS_15_TO_0_1_ULE_6010___d73) &&
	     fifoCheck$D_OUT[63:32] != 32'hC0A80F04 &&
	     fifoCheck$D_OUT[95:64] != 32'hC0A83303 &&
	     (fifoCheck$D_OUT[63:32] != 32'hC0A83303 ||
	      fifoCheck$D_OUT[15:0] != 16'd6000) ;
  assign fifoCheck_first__1_BITS_31_TO_16_6_ULT_6000___d67 =
	     fifoCheck$D_OUT[31:16] < 16'd6000 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        active <= `BSV_ASSIGNMENT_DELAY 1'd0;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tx_data <= `BSV_ASSIGNMENT_DELAY 64'hAAAAAAAAAAAAAAAA;
	tx_keep <= `BSV_ASSIGNMENT_DELAY 8'hFF;
	tx_last <= `BSV_ASSIGNMENT_DELAY 1'b0;
	tx_ready <= `BSV_ASSIGNMENT_DELAY 1'b1;
	tx_user <= `BSV_ASSIGNMENT_DELAY 1'b0;
	tx_valid <= `BSV_ASSIGNMENT_DELAY 1'b0;
      end
    else
      begin
        if (active$EN) active <= `BSV_ASSIGNMENT_DELAY active$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (start_reg$EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg$D_IN;
	if (start_reg_1$EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1$D_IN;
	if (state_can_overlap$EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap$D_IN;
	if (state_fired$EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired$D_IN;
	if (state_mkFSMstate$EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate$D_IN;
	if (tx_data$EN) tx_data <= `BSV_ASSIGNMENT_DELAY tx_data$D_IN;
	if (tx_keep$EN) tx_keep <= `BSV_ASSIGNMENT_DELAY tx_keep$D_IN;
	if (tx_last$EN) tx_last <= `BSV_ASSIGNMENT_DELAY tx_last$D_IN;
	if (tx_ready$EN) tx_ready <= `BSV_ASSIGNMENT_DELAY tx_ready$D_IN;
	if (tx_user$EN) tx_user <= `BSV_ASSIGNMENT_DELAY tx_user$D_IN;
	if (tx_valid$EN) tx_valid <= `BSV_ASSIGNMENT_DELAY tx_valid$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    active = 1'h0;
    running = 1'h0;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 4'hA;
    tx_data = 64'hAAAAAAAAAAAAAAAA;
    tx_keep = 8'hAA;
    tx_last = 1'h0;
    tx_ready = 1'h0;
    tx_user = 1'h0;
    tx_valid = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l118c50 &&
	  (WILL_FIRE_RL_action_l122c49 || WILL_FIRE_RL_action_l128c41 ||
	   WILL_FIRE_RL_action_l141c50 ||
	   WILL_FIRE_RL_action_l145c49 ||
	   WILL_FIRE_RL_action_l151c41 ||
	   WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 118, column 50: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l118c50] and\n  [RL_action_l122c49, RL_action_l128c41, RL_action_l141c50, RL_action_l145c49,\n  RL_action_l151c41, RL_action_l162c50, RL_action_l166c49, RL_action_l172c41,\n  RL_action_l183c50, RL_action_l186c55, RL_action_l188c47] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l122c49 &&
	  (WILL_FIRE_RL_action_l128c41 || WILL_FIRE_RL_action_l141c50 ||
	   WILL_FIRE_RL_action_l145c49 ||
	   WILL_FIRE_RL_action_l151c41 ||
	   WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 122, column 49: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l122c49] and\n  [RL_action_l128c41, RL_action_l141c50, RL_action_l145c49, RL_action_l151c41,\n  RL_action_l162c50, RL_action_l166c49, RL_action_l172c41, RL_action_l183c50,\n  RL_action_l186c55, RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l128c41 &&
	  (WILL_FIRE_RL_action_l141c50 || WILL_FIRE_RL_action_l145c49 ||
	   WILL_FIRE_RL_action_l151c41 ||
	   WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 128, column 41: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l128c41] and\n  [RL_action_l141c50, RL_action_l145c49, RL_action_l151c41, RL_action_l162c50,\n  RL_action_l166c49, RL_action_l172c41, RL_action_l183c50, RL_action_l186c55,\n  RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l141c50 &&
	  (WILL_FIRE_RL_action_l145c49 || WILL_FIRE_RL_action_l151c41 ||
	   WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 141, column 50: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l141c50] and\n  [RL_action_l145c49, RL_action_l151c41, RL_action_l162c50, RL_action_l166c49,\n  RL_action_l172c41, RL_action_l183c50, RL_action_l186c55, RL_action_l188c47]\n  ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l145c49 &&
	  (WILL_FIRE_RL_action_l151c41 || WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 145, column 49: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l145c49] and\n  [RL_action_l151c41, RL_action_l162c50, RL_action_l166c49, RL_action_l172c41,\n  RL_action_l183c50, RL_action_l186c55, RL_action_l188c47] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l151c41 &&
	  (WILL_FIRE_RL_action_l162c50 || WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 151, column 41: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l151c41] and\n  [RL_action_l162c50, RL_action_l166c49, RL_action_l172c41, RL_action_l183c50,\n  RL_action_l186c55, RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l162c50 &&
	  (WILL_FIRE_RL_action_l166c49 || WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 162, column 50: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l162c50] and\n  [RL_action_l166c49, RL_action_l172c41, RL_action_l183c50, RL_action_l186c55,\n  RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l166c49 &&
	  (WILL_FIRE_RL_action_l172c41 || WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 166, column 49: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l166c49] and\n  [RL_action_l172c41, RL_action_l183c50, RL_action_l186c55, RL_action_l188c47]\n  ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l172c41 &&
	  (WILL_FIRE_RL_action_l183c50 || WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 172, column 41: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l172c41] and\n  [RL_action_l183c50, RL_action_l186c55, RL_action_l188c47] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l186c55 && WILL_FIRE_RL_action_l188c47)
	$display("Error: \"Filter.bsv\", line 186, column 55: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l186c55] and\n  [RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l183c50 &&
	  (WILL_FIRE_RL_action_l186c55 || WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 183, column 50: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l183c50] and\n  [RL_action_l186c55, RL_action_l188c47] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l110c30 &&
	  (WILL_FIRE_RL_action_l118c50 || WILL_FIRE_RL_action_l122c49 ||
	   WILL_FIRE_RL_action_l128c41 ||
	   WILL_FIRE_RL_action_l141c50 ||
	   WILL_FIRE_RL_action_l145c49 ||
	   WILL_FIRE_RL_action_l151c41 ||
	   WILL_FIRE_RL_action_l162c50 ||
	   WILL_FIRE_RL_action_l166c49 ||
	   WILL_FIRE_RL_action_l172c41 ||
	   WILL_FIRE_RL_action_l183c50 ||
	   WILL_FIRE_RL_action_l186c55 ||
	   WILL_FIRE_RL_action_l188c47))
	$display("Error: \"Filter.bsv\", line 110, column 30: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l110c30] and\n  [RL_action_l118c50, RL_action_l122c49, RL_action_l128c41, RL_action_l141c50,\n  RL_action_l145c49, RL_action_l151c41, RL_action_l162c50, RL_action_l166c49,\n  RL_action_l172c41, RL_action_l183c50, RL_action_l186c55, RL_action_l188c47]\n  ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d201 &&
	  !start_reg)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkFilter

